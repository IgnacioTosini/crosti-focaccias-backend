spring.application.name=crosti-focaccias

# Cloudinary config
cloudinary.cloud_name=${CLOUDINARY_CLOUD_NAME:dt1wkwlxc}
cloudinary.api_key=${CLOUDINARY_API_KEY:636186212435821}
cloudinary.api_secret=${CLOUDINARY_API_SECRET:u6X0ypUkYOYEsBR7bpZraOqfXik}
cloudinary.upload_preset=${CLOUDINARY_UPLOAD_PRESET:crostiFocaccias_preset}

# Configuración de Base de Datos
# Local: MySQL | Producción: PostgreSQL (Neon)
spring.datasource.url=${DATABASE_URL:jdbc:postgresql://ep-silent-resonance-acf17e0m-pooler.sa-east-1.aws.neon.tech/neondb?sslmode=require}
spring.datasource.username=${DATABASE_USERNAME:neondb_owner}
spring.datasource.password=${DATABASE_PASSWORD:npg_pjHsyuW9AXo3}
spring.datasource.driver-class-name=${DATABASE_DRIVER:org.postgresql.Driver}

# JPA/Hibernate - Optimizado para minimizar consumo en Neon
spring.jpa.database-platform=${DATABASE_DIALECT:org.hibernate.dialect.PostgreSQLDialect}
spring.jpa.show-sql=${SHOW_SQL:false}
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.properties.hibernate.dialect=${DATABASE_DIALECT:org.hibernate.dialect.PostgreSQLDialect}
spring.jpa.properties.hibernate.physical_naming_strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# Optimización adicional de conexiones para reducir consumo
spring.datasource.hikari.maximum-pool-size=2
spring.datasource.hikari.minimum-idle=1
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000

# CORS - Permitir frontend (configurar en variables de entorno)
# Local: http://localhost:5173
# Producción: https://crosti-focaccias-frontend.vercel.app
cors.allowed.origins=${FRONTEND_URL:http://localhost:5173}

# Puerto (Render usa la variable PORT)
server.port=${PORT:8080}

# Configuración adicional para PostgreSQL en producción
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

